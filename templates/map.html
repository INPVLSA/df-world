{% extends "base.html" %}

{% block title %}World Map - DF Tales{% endblock %}

{% block content %}
<h1>{% if world and world.has_plus and world.name %}{{ world.name|title }} Map{% else %}World Map{% endif %}</h1>

<div class="map-container">
    <div class="map-controls">
        <button id="zoom-in" class="map-btn" title="Zoom In">+</button>
        <button id="zoom-out" class="map-btn" title="Zoom Out">-</button>
        <button id="zoom-reset" class="map-btn" title="Reset">R</button>
        <button id="legend-toggle" class="map-btn active" title="Toggle Legend">&#9776;</button>
        <div class="map-search-wrapper">
            <input type="text" id="map-search" class="map-search-input" placeholder="Search sites...">
            <div class="map-search-results" id="map-search-results"></div>
        </div>
        <span class="map-info">{{ total_sites }} sites, {{ total_peaks }} peaks</span>
        <span class="map-coords" id="map-coords"></span>
    </div>

    <div class="map-legend-dropdown open" id="map-legend">
        <div class="legend-tabs">
            <button class="legend-tab active" data-tab="sites">Sites</button>
            <button class="legend-tab" data-tab="peaks">Peaks</button>
            <button class="legend-tab" data-tab="overlays">Overlays</button>
        </div>

        <div class="legend-tab-content" id="tab-sites">
            <div class="legend-items">
                {% for tc in type_counts %}
                {% set ti = get_site_type_info(tc.type) %}
                <label class="legend-item">
                    <input type="checkbox" checked data-type="{{ tc.type|replace(' ', '-') }}" class="legend-toggle site-toggle">
                    {% if ti.img %}
                    <img src="{{ ti.img }}" alt="{{ ti.icon }}" class="legend-icon">
                    {% else %}
                    <span class="legend-icon-text">{{ ti.icon }}</span>
                    {% endif %}
                    <span class="legend-label">{{ ti.label }}</span>
                    <span class="legend-count">({{ tc.count }})</span>
                </label>
                {% endfor %}
            </div>
            <div class="legend-actions">
                <button id="legend-all-sites" class="legend-btn">All</button>
                <button id="legend-none-sites" class="legend-btn">None</button>
            </div>
        </div>

        <div class="legend-tab-content" id="tab-peaks" style="display: none;">
            <div class="legend-items">
                <label class="legend-item">
                    <input type="checkbox" checked data-type="peak" class="legend-toggle peak-toggle">
                    <span class="legend-icon-text">&#9650;</span>
                    <span class="legend-label">Mountain Peaks</span>
                    <span class="legend-count">({{ total_peaks }})</span>
                </label>
                <label class="legend-item">
                    <input type="checkbox" checked data-type="volcano" class="legend-toggle peak-toggle">
                    <span class="legend-icon-text" style="color: #ff4500;">&#9650;</span>
                    <span class="legend-label">Volcanoes</span>
                    <span class="legend-count">({{ peaks|selectattr('is_volcano')|list|length }})</span>
                </label>
            </div>
            <div class="legend-peaks-list">
                {% for peak in peaks %}
                <div class="legend-peak-item" data-peak-id="{{ peak.id }}" data-x="{{ peak.x }}" data-y="{{ peak.y }}">
                    <span class="peak-icon{% if peak.is_volcano %} volcano{% endif %}">&#9650;</span>
                    <span class="peak-name">{{ peak.name }}</span>
                    <span class="peak-height">{{ peak.height }}m</span>
                </div>
                {% endfor %}
            </div>
        </div>

        <div class="legend-tab-content" id="tab-overlays" style="display: none;">
            <div class="legend-items">
                <label class="legend-item">
                    <input type="checkbox" checked id="toggle-rivers" class="legend-toggle overlay-toggle">
                    <span class="legend-icon-text" style="color: #4169e1;">~</span>
                    <span class="legend-label">Rivers</span>
                    <span class="legend-count">({{ total_rivers }})</span>
                </label>
                <label class="legend-item">
                    <input type="checkbox" checked id="toggle-roads" class="legend-toggle overlay-toggle">
                    <span class="legend-icon-text" style="color: #8b7765;">-</span>
                    <span class="legend-label">Roads</span>
                    <span class="legend-count">({{ total_roads }})</span>
                </label>
            </div>
        </div>
    </div>

    <div class="map-viewport" id="map-viewport" style="aspect-ratio: {{ map_width }} / {{ map_height }};">
        <div class="map-canvas{% if has_map %} has-bg{% endif %}" id="map-canvas"
             {% if has_map %}style="background-image: url('{{ url_for('worlds.world_map_image', world_id=world_id) }}');"{% endif %}>
            <canvas id="overlay-canvas" class="map-overlay-canvas"></canvas>
            {% for site in sites %}
            <div class="map-marker site-marker type-{{ site.type|replace(' ', '-') }}"
                 data-id="{{ site.id }}"
                 data-name="{{ site.name }}"
                 data-type="{{ site.type_label }}"
                 data-civ="{{ site.civ_label or '' }}"
                 style="left: {{ ((site.x - min_x + 0.5) / map_width * 100) }}%; top: {{ ((site.y - min_y + 0.5) / map_height * 100) }}%;"
                 title="{{ site.name }}">
                {% if site.type_img %}
                <img src="{{ site.type_img }}" alt="{{ site.type_icon }}" class="marker-icon">
                {% else %}
                <span class="marker-text">{{ site.type_icon }}</span>
                {% endif %}
            </div>
            {% endfor %}

            {% for peak in peaks %}
            <div class="map-marker peak-marker{% if peak.is_volcano %} volcano{% endif %}"
                 data-id="{{ peak.id }}"
                 data-name="{{ peak.name }}"
                 data-height="{{ peak.height }}"
                 data-volcano="{{ peak.is_volcano }}"
                 style="left: {{ ((peak.x - min_x + 0.5) / map_width * 100) }}%; top: {{ ((peak.y - min_y + 0.5) / map_height * 100) }}%;"
                 title="{{ peak.name }}">
                <span class="marker-text peak-icon">&#9650;</span>
            </div>
            {% endfor %}
        </div>
    </div>

    <div class="map-tooltip" id="map-tooltip"></div>

    {% if has_map %}
    <div class="mini-map" id="mini-map">
        <img src="{{ url_for('worlds.world_map_image', world_id=world_id) }}" alt="Mini-map" class="mini-map-img">
        <div class="mini-map-viewport" id="mini-map-viewport"></div>
    </div>
    {% endif %}
</div>

<script>
(function() {
    var viewport = document.getElementById('map-viewport');
    var canvas = document.getElementById('map-canvas');
    var tooltip = document.getElementById('map-tooltip');
    var siteMarkers = document.querySelectorAll('.site-marker');
    var peakMarkers = document.querySelectorAll('.peak-marker');
    var legend = document.getElementById('map-legend');
    var legendToggle = document.getElementById('legend-toggle');

    var scale = 1;
    var minScale = 0.5;
    var maxScale = 5;
    var panX = 0, panY = 0;
    var isDragging = false;
    var startX, startY, startPanX, startPanY;

    // Search elements
    var searchInput = document.getElementById('map-search');
    var searchResults = document.getElementById('map-search-results');
    var searchTimeout = null;

    // Map bounds for coordinate calculation
    var minX = {{ min_x }};
    var minY = {{ min_y }};
    var mapWidth = {{ map_width }};
    var mapHeight = {{ map_height }};

    function updateTransform() {
        canvas.style.transform = 'translate(' + panX + 'px, ' + panY + 'px) scale(' + scale + ')';
    }

    // Navigate to coordinates
    function navigateTo(xPercent, yPercent) {
        var viewportRect = viewport.getBoundingClientRect();

        // Set zoom level first
        scale = Math.min(maxScale, 3);

        // Point position relative to canvas center (since transform-origin is center)
        var pointX = (xPercent / 100 - 0.5) * canvas.offsetWidth;
        var pointY = (yPercent / 100 - 0.5) * canvas.offsetHeight;

        // Pan so that point is at viewport center
        panX = -pointX * scale;
        panY = -pointY * scale;

        updateTransform();
    }

    // Legend dropdown toggle
    legendToggle.addEventListener('click', function(e) {
        e.stopPropagation();
        legend.classList.toggle('open');
        legendToggle.classList.toggle('active');
    });

    // Close legend when clicking outside
    document.addEventListener('click', function(e) {
        if (window.innerWidth < 1024 && !legend.contains(e.target) && e.target !== legendToggle) {
            legend.classList.remove('open');
            legendToggle.classList.remove('active');
        }

        // Close search results when clicking outside
        if (window.innerWidth < 1024 && !searchResults.contains(e.target) && e.target !== searchInput) {
            searchResults.classList.remove('open');
        }
    });

    // Site search functionality
    function titleCase(str) {
        if (!str) return '(unnamed)';
        return str.replace(/\b\w/g, function(c) { return c.toUpperCase(); });
    }

    function performSearch(query) {
        if (query.length < 2) {
            searchResults.classList.remove('open');
            return;
        }

        fetch('/map/search?q=' + encodeURIComponent(query))
            .then(function(r) { return r.json(); })
            .then(function(results) {
                if (results.length === 0) {
                    searchResults.innerHTML = '<div class="map-search-empty">No sites found</div>';
                } else {
                    var html = '';
                    results.forEach(function(site) {
                        var icon = site.type_img
                            ? '<img src="' + site.type_img + '" alt="">'
                            : '<span class="result-icon">' + site.type_icon + '</span>';
                        html += '<div class="map-search-result" data-x="' + site.x + '" data-y="' + site.y + '" data-id="' + site.id + '">' +
                            icon +
                            '<span class="result-name">' + titleCase(site.name) + '</span>' +
                            '<span class="result-type">' + site.type + '</span>' +
                            '</div>';
                    });
                    searchResults.innerHTML = html;
                }
                searchResults.classList.add('open');
            });
    }

    searchInput.addEventListener('input', function() {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(function() {
            performSearch(searchInput.value.trim());
        }, 200);
    });

    searchInput.addEventListener('focus', function() {
        if (searchInput.value.trim().length >= 2) {
            performSearch(searchInput.value.trim());
        }
    });

    searchResults.addEventListener('click', function(e) {
        var result = e.target.closest('.map-search-result');
        if (result) {
            var x = parseFloat(result.dataset.x);
            var y = parseFloat(result.dataset.y);
            var xPercent = ((x - minX + 0.5) / mapWidth) * 100;
            var yPercent = ((y - minY + 0.5) / mapHeight) * 100;

            navigateTo(xPercent, yPercent);
            searchResults.classList.remove('open');
            searchInput.value = '';

            // Highlight the site marker briefly
            var siteId = result.dataset.id;
            var marker = document.querySelector('.site-marker[data-id="' + siteId + '"]');
            if (marker) {
                marker.classList.add('highlight');
                setTimeout(function() { marker.classList.remove('highlight'); }, 2000);
            }
        }
    });

    // Tab switching
    document.querySelectorAll('.legend-tab').forEach(function(tab) {
        tab.addEventListener('click', function(e) {
            e.stopPropagation();
            document.querySelectorAll('.legend-tab').forEach(function(t) { t.classList.remove('active'); });
            document.querySelectorAll('.legend-tab-content').forEach(function(c) { c.style.display = 'none'; });
            tab.classList.add('active');
            document.getElementById('tab-' + tab.dataset.tab).style.display = 'block';
        });
    });

    // Zoom controls
    document.getElementById('zoom-in').addEventListener('click', function() {
        scale = Math.min(maxScale, scale * 1.3);
        updateTransform();
    });

    document.getElementById('zoom-out').addEventListener('click', function() {
        scale = Math.max(minScale, scale / 1.3);
        updateTransform();
    });

    document.getElementById('zoom-reset').addEventListener('click', function() {
        scale = 1;
        panX = 0;
        panY = 0;
        updateTransform();
    });

    // Mouse wheel zoom - zoom toward cursor position
    viewport.addEventListener('wheel', function(e) {
        e.preventDefault();
        var rect = viewport.getBoundingClientRect();
        var mouseX = e.clientX - rect.left;
        var mouseY = e.clientY - rect.top;

        // Point on canvas under cursor (before zoom)
        var canvasCenterX = rect.width / 2;
        var canvasCenterY = rect.height / 2;
        var pointX = (mouseX - canvasCenterX - panX) / scale;
        var pointY = (mouseY - canvasCenterY - panY) / scale;

        var delta = e.deltaY > 0 ? 0.9 : 1.1;
        var newScale = Math.max(minScale, Math.min(maxScale, scale * delta));

        // Adjust pan so the same point stays under cursor
        panX = mouseX - canvasCenterX - pointX * newScale;
        panY = mouseY - canvasCenterY - pointY * newScale;

        scale = newScale;
        updateTransform();
    });

    // Pan with drag
    viewport.addEventListener('mousedown', function(e) {
        if (e.target.classList.contains('map-marker') || e.target.closest('.map-marker')) return;
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startPanX = panX;
        startPanY = panY;
        viewport.style.cursor = 'grabbing';
    });

    document.addEventListener('mousemove', function(e) {
        if (!isDragging) return;
        panX = startPanX + (e.clientX - startX);
        panY = startPanY + (e.clientY - startY);
        updateTransform();
    });

    document.addEventListener('mouseup', function() {
        isDragging = false;
        viewport.style.cursor = 'grab';
    });

    // Coordinate display on hover
    var coordsDisplay = document.getElementById('map-coords');

    function updateCoords(e) {
        var rect = viewport.getBoundingClientRect();
        var mouseX = e.clientX - rect.left;
        var mouseY = e.clientY - rect.top;

        // Convert mouse position to canvas position (accounting for pan and scale)
        var canvasCenterX = rect.width / 2;
        var canvasCenterY = rect.height / 2;
        var canvasX = (mouseX - canvasCenterX - panX) / scale + canvasCenterX;
        var canvasY = (mouseY - canvasCenterY - panY) / scale + canvasCenterY;

        // Convert canvas position to world coordinates
        var worldX = Math.floor((canvasX / rect.width) * mapWidth + minX);
        var worldY = Math.floor((canvasY / rect.height) * mapHeight + minY);

        // Check if within bounds
        if (worldX >= minX && worldX < minX + mapWidth && worldY >= minY && worldY < minY + mapHeight) {
            coordsDisplay.textContent = 'X: ' + worldX + ', Y: ' + worldY;
            coordsDisplay.style.display = '';
        } else {
            coordsDisplay.style.display = 'none';
        }
    }

    viewport.addEventListener('mousemove', updateCoords);

    viewport.addEventListener('mouseleave', function() {
        coordsDisplay.style.display = 'none';
    });

    // Site marker tooltips
    siteMarkers.forEach(function(marker) {
        marker.addEventListener('mouseenter', function(e) {
            var name = marker.dataset.name || 'Unknown';
            var type = marker.dataset.type || '';
            var civ = marker.dataset.civ;

            var html = '<strong>' + name + '</strong><br>' + type;
            if (civ) html += '<br><span class="tooltip-civ">' + civ + '</span>';

            tooltip.innerHTML = html;
            tooltip.style.display = 'block';
        });

        marker.addEventListener('mousemove', function(e) {
            tooltip.style.left = (e.clientX + 15) + 'px';
            tooltip.style.top = (e.clientY + 15) + 'px';
        });

        marker.addEventListener('mouseleave', function() {
            tooltip.style.display = 'none';
        });

        marker.addEventListener('click', function() {
            var id = marker.dataset.id;
            if (typeof EntityModal !== 'undefined' && EntityModal.load) {
                EntityModal.load('site', id);
            } else {
                window.location.href = '/site/' + id;
            }
        });
    });

    // Peak marker tooltips
    peakMarkers.forEach(function(marker) {
        marker.addEventListener('mouseenter', function(e) {
            var name = marker.dataset.name || 'Unknown';
            var height = marker.dataset.height || '';
            var isVolcano = marker.dataset.volcano === '1';

            var html = '<strong>' + name + '</strong><br>';
            html += isVolcano ? '<span style="color:#ff4500;">Volcano</span>' : 'Mountain Peak';
            html += '<br>Height: ' + height + 'm';

            tooltip.innerHTML = html;
            tooltip.style.display = 'block';
        });

        marker.addEventListener('mousemove', function(e) {
            tooltip.style.left = (e.clientX + 15) + 'px';
            tooltip.style.top = (e.clientY + 15) + 'px';
        });

        marker.addEventListener('mouseleave', function() {
            tooltip.style.display = 'none';
        });

        marker.addEventListener('click', function() {
            var id = marker.dataset.id;
            window.location.href = '/peak/' + id;
        });
    });

    // Site visibility toggle
    function updateSiteVisibility() {
        document.querySelectorAll('.site-toggle').forEach(function(checkbox) {
            var type = checkbox.dataset.type;
            var visible = checkbox.checked;
            document.querySelectorAll('.site-marker.type-' + type).forEach(function(m) {
                m.style.display = visible ? '' : 'none';
            });
        });
    }

    // Peak visibility toggle
    function updatePeakVisibility() {
        var showPeaks = document.querySelector('.peak-toggle[data-type="peak"]').checked;
        var showVolcanoes = document.querySelector('.peak-toggle[data-type="volcano"]').checked;

        peakMarkers.forEach(function(m) {
            var isVolcano = m.dataset.volcano === '1';
            if (isVolcano) {
                m.style.display = showVolcanoes ? '' : 'none';
            } else {
                m.style.display = showPeaks ? '' : 'none';
            }
        });
    }

    document.querySelectorAll('.site-toggle').forEach(function(checkbox) {
        checkbox.addEventListener('change', updateSiteVisibility);
    });

    document.querySelectorAll('.peak-toggle').forEach(function(checkbox) {
        checkbox.addEventListener('change', updatePeakVisibility);
    });

    // All/None buttons for sites
    document.getElementById('legend-all-sites').addEventListener('click', function() {
        document.querySelectorAll('.site-toggle').forEach(function(cb) { cb.checked = true; });
        updateSiteVisibility();
    });

    document.getElementById('legend-none-sites').addEventListener('click', function() {
        document.querySelectorAll('.site-toggle').forEach(function(cb) { cb.checked = false; });
        updateSiteVisibility();
    });

    // Peak list navigation
    document.querySelectorAll('.legend-peak-item').forEach(function(item) {
        item.addEventListener('click', function(e) {
            e.stopPropagation();
            var x = parseFloat(item.dataset.x);
            var y = parseFloat(item.dataset.y);
            var minX = {{ min_x }};
            var minY = {{ min_y }};
            var mapWidth = {{ map_width }};
            var mapHeight = {{ map_height }};

            var xPercent = ((x - minX + 0.5) / mapWidth) * 100;
            var yPercent = ((y - minY + 0.5) / mapHeight) * 100;

            navigateTo(xPercent, yPercent);

            // Highlight the peak marker briefly
            var peakId = item.dataset.peakId;
            var marker = document.querySelector('.peak-marker[data-id="' + peakId + '"]');
            if (marker) {
                marker.classList.add('highlight');
                setTimeout(function() { marker.classList.remove('highlight'); }, 2000);
            }
        });
    });

    // Handle hash navigation from site modal "View on Map" button
    function handleHashNavigation() {
        var hash = window.location.hash;
        if (hash && hash.indexOf('site=') !== -1) {
            var params = {};
            hash.substring(1).split('&').forEach(function(part) {
                var kv = part.split('=');
                if (kv.length === 2) params[kv[0]] = kv[1];
            });

            if (params.coords) {
                var coords = params.coords.split(',');
                if (coords.length === 2) {
                    var x = parseInt(coords[0]);
                    var y = parseInt(coords[1]);
                    var xPercent = ((x - minX + 0.5) / mapWidth) * 100;
                    var yPercent = ((y - minY + 0.5) / mapHeight) * 100;

                    // Small delay to ensure page is ready
                    setTimeout(function() {
                        navigateTo(xPercent, yPercent);

                        // Highlight the site marker
                        if (params.site) {
                            var marker = document.querySelector('.site-marker[data-id="' + params.site + '"]');
                            if (marker) {
                                marker.classList.add('highlight');
                                setTimeout(function() { marker.classList.remove('highlight'); }, 2000);
                            }
                        }
                    }, 100);
                }
            }
            // Clear hash after navigation
            history.replaceState(null, '', window.location.pathname);
        }
    }

    // Run on page load
    handleHashNavigation();

    // === River and Road Overlay ===
    var overlayCanvas = document.getElementById('overlay-canvas');
    var ctx = overlayCanvas.getContext('2d');

    // River and road data from server
    var rivers = {{ rivers|tojson }};
    var roads = {{ roads|tojson }};

    // Overlay visibility state
    var showRivers = true;
    var showRoads = true;

    // Tile size matches terrain map generation (32px per tile)
    var tileSize = 32;
    var canvasWidth = mapWidth * tileSize;
    var canvasHeight = mapHeight * tileSize;

    // Set canvas size to match terrain map resolution
    function resizeOverlayCanvas() {
        overlayCanvas.width = canvasWidth;
        overlayCanvas.height = canvasHeight;
        drawOverlays();
    }

    // Convert world coords to canvas pixels (matching terrain map generator)
    function worldToCanvas(x, y) {
        var px = (x - minX) * tileSize + tileSize / 2;
        var py = (y - minY) * tileSize + tileSize / 2;
        return [px, py];
    }

    // Draw all overlays
    function drawOverlays() {
        ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

        if (showRivers) {
            drawRivers();
        }
        if (showRoads) {
            drawRoads();
        }
    }

    // Draw rivers
    function drawRivers() {
        rivers.forEach(function(river) {
            var segments = river.segments;
            if (!segments || segments.length < 2) return;

            // Draw each segment individually to allow varying widths
            for (var i = 0; i < segments.length - 1; i++) {
                var seg = segments[i];
                var nextSeg = segments[i + 1];
                var pos = worldToCanvas(seg.x, seg.y);
                var nextPos = worldToCanvas(nextSeg.x, nextSeg.y);

                // Line width based on river width (scale 2-13 to 1-4 pixels at full resolution)
                var lineWidth = 1 + (seg.w / 13) * 3;

                // Color based on width
                var color = seg.w > 8
                    ? 'rgba(65, 105, 225, 0.8)'   // Royal blue for wide
                    : 'rgba(100, 149, 237, 0.7)'; // Cornflower for narrow

                ctx.beginPath();
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color;
                ctx.lineCap = 'round';
                ctx.moveTo(pos[0], pos[1]);
                ctx.lineTo(nextPos[0], nextPos[1]);
                ctx.stroke();
            }
        });
    }

    // Draw roads, tunnels, bridges
    function drawRoads() {
        roads.forEach(function(road) {
            var points = road.points;
            if (!points || points.length < 1) return;

            var roadType = road.type;
            ctx.beginPath();

            // Style based on type
            if (roadType === 'road') {
                ctx.strokeStyle = 'rgba(139, 119, 101, 0.8)';
                ctx.lineWidth = 2;
            } else if (roadType === 'tunnel') {
                ctx.strokeStyle = 'rgba(90, 90, 90, 0.7)';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
            } else if (roadType === 'bridge') {
                ctx.strokeStyle = 'rgba(160, 82, 45, 0.9)';
                ctx.lineWidth = 3;
            }

            if (points.length === 1) {
                // Single point (bridge) - draw a small square
                var pos = worldToCanvas(points[0].x, points[0].y);
                ctx.fillStyle = ctx.strokeStyle;
                ctx.fillRect(pos[0] - 3, pos[1] - 3, 6, 6);
            } else {
                // Multiple points - draw line
                for (var i = 0; i < points.length; i++) {
                    var pos = worldToCanvas(points[i].x, points[i].y);
                    if (i === 0) {
                        ctx.moveTo(pos[0], pos[1]);
                    } else {
                        ctx.lineTo(pos[0], pos[1]);
                    }
                }
                ctx.stroke();
            }

            // Reset line dash
            ctx.setLineDash([]);
        });
    }

    // Toggle handlers
    document.getElementById('toggle-rivers').addEventListener('change', function() {
        showRivers = this.checked;
        drawOverlays();
    });

    document.getElementById('toggle-roads').addEventListener('change', function() {
        showRoads = this.checked;
        drawOverlays();
    });

    // Initialize canvas on load
    setTimeout(function() {
        resizeOverlayCanvas();
    }, 100);

    // Redraw on window resize
    window.addEventListener('resize', function() {
        resizeOverlayCanvas();
    });

    // === Mini-map ===
    var miniMap = document.getElementById('mini-map');
    var miniMapViewport = document.getElementById('mini-map-viewport');

    if (miniMap && miniMapViewport) {
        // Update mini-map viewport indicator
        function updateMiniMap() {
            var viewportRect = viewport.getBoundingClientRect();

            // Calculate visible area in canvas coordinates
            var canvasCenterX = viewportRect.width / 2;
            var canvasCenterY = viewportRect.height / 2;

            // Visible rect corners in unscaled canvas coordinates
            var visLeft = (0 - canvasCenterX - panX) / scale + canvasCenterX;
            var visTop = (0 - canvasCenterY - panY) / scale + canvasCenterY;
            var visRight = (viewportRect.width - canvasCenterX - panX) / scale + canvasCenterX;
            var visBottom = (viewportRect.height - canvasCenterY - panY) / scale + canvasCenterY;

            // Convert to percentages of the full map
            var leftPct = Math.max(0, (visLeft / viewportRect.width) * 100);
            var topPct = Math.max(0, (visTop / viewportRect.height) * 100);
            var widthPct = Math.min(100 - leftPct, ((visRight - visLeft) / viewportRect.width) * 100);
            var heightPct = Math.min(100 - topPct, ((visBottom - visTop) / viewportRect.height) * 100);

            miniMapViewport.style.left = leftPct + '%';
            miniMapViewport.style.top = topPct + '%';
            miniMapViewport.style.width = widthPct + '%';
            miniMapViewport.style.height = heightPct + '%';

            // Show mini-map only when zoomed in
            if (scale > 1.2) {
                miniMap.classList.add('visible');
            } else {
                miniMap.classList.remove('visible');
            }
        }

        // Update on transform changes
        var originalUpdateTransform = updateTransform;
        updateTransform = function() {
            originalUpdateTransform();
            updateMiniMap();
        };

        // Click on mini-map to navigate
        miniMap.addEventListener('click', function(e) {
            var rect = miniMap.getBoundingClientRect();
            var clickX = (e.clientX - rect.left) / rect.width;
            var clickY = (e.clientY - rect.top) / rect.height;

            // Navigate to clicked position (center it in viewport)
            var viewportRect = viewport.getBoundingClientRect();
            var targetX = (clickX - 0.5) * viewportRect.width;
            var targetY = (clickY - 0.5) * viewportRect.height;

            panX = -targetX * scale;
            panY = -targetY * scale;
            updateTransform();
        });

        // Initial update
        updateMiniMap();
    }
})();
</script>
{% endblock %}
